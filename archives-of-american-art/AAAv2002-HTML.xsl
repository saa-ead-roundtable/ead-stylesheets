<!-- stephboxfolder generated by Steph 6/05 using Loren's stylesheet generated by Loren 1/31/02 from E AD Cookbook Style 2 and Michael Fox's changes to the container list Version 0.9   2000 July 22; incorporating changes attempting to accomodate EAD Cookbook v. 2  -->
<!--  This stylesheet generates Style 2 and Michael Fox's addition for boxes and folders which has a Table of Contents in an HTML table cell along the left side of the screen. It may be used when an HTML frame is not desired.  -->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:ead="urn:isbn:1-931666-22-9"
            xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.w3.org/1999/xhtml" xmlns:fn="http://www.w3.org/2005/02/xpath-functions"
            xmlns:xdt="http://www.w3.org/2005/02/xpath-datatypes" xmlns:xlink="http://www.w3.org/1999/xlink">
			
<xsl:output method="xml" indent="yes" encoding="UTF-8"/>
<xsl:strip-space elements="*"/>

<!-- Creates the body of the finding aid.-->
<xsl:template match="/">
	<html>
		<head>
			<xsl:call-template name="head"/>
		</head>
	
	
		<body>
			<table width="100%" cellpadding="5">
				<tr><td width="20%"></td><td width="80%"></td></tr>
				<tr>
					<td valign="top" bgcolor="#CCCCCC"><xsl:call-template name="toc"/></td>
					<td valign="top" bgcolor="#FFFFFF">
						<!-- The ead header contains the cover page information -->
						<xsl:call-template name="cover"/>
						<xsl:call-template name="archdesc-did"/>
						<xsl:call-template name="archdesc-admininfo"/>
						<xsl:call-template name="archdesc-bioghist"/>
						<xsl:call-template name="archdesc-scopecontent"/>
						<xsl:call-template name="archdesc-control"/>
						<xsl:call-template name="archdesc-arrangement"/>
						<xsl:call-template name="dsc"/>
						<xsl:call-template name="archdesc-odd"/>
						<xsl:call-template name="archdesc-otherfindaid"/>
						<xsl:call-template name="archdesc-bibliography"/>
					</td>
				</tr>
			</table>
		</body>
	</html>
</xsl:template>

	<xsl:template name="head">
		<style> h1, h2, h3, h4 {font-family: arial}</style> 
		<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
		<title>
			<xsl:value-of select="ead/eadheader/filedesc/titlestmt/subtitle" />
		</title>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.title</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead/eadheader/filedesc/titlestmt/titleproper" /><xsl:text> </xsl:text><xsl:value-of select="ead/eadheader/filedesc/titlestmt/subtitle" /></xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.author</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead/archdesc/did/origination" /></xsl:attribute>
		</xsl:element>
		<xsl:for-each select="ead//controlaccess/persname | ead//controlaccess/corpname">
			<xsl:choose>
				<xsl:when test="@encodinganalog='600'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='610'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='611'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.subject</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='700'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='710'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:when test="@encodinganalog='711'">
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:when>
				<xsl:otherwise>
					<xsl:element name="meta">
						<xsl:attribute name="name">dc.contributor</xsl:attribute>
						<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
					</xsl:element>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
		<xsl:for-each select="ead//controlaccess/subject">
			<xsl:element name="meta">
				<xsl:attribute name="name">dc.subject</xsl:attribute>
				<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
			</xsl:element>
		</xsl:for-each>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.title</xsl:attribute>
			<xsl:attribute name="content"><xsl:value-of select="ead/archdesc/did/unittitle" /></xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.type</xsl:attribute>
			<xsl:attribute name="content">text</xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.format</xsl:attribute>
			<xsl:attribute name="content">manuscripts</xsl:attribute>
		</xsl:element>
		<xsl:element name="meta">
			<xsl:attribute name="name">dc.format</xsl:attribute>
			<xsl:attribute name="content">finding aids</xsl:attribute>
		</xsl:element>
		<xsl:for-each select="ead//controlaccess/geogname">
			<xsl:element name="meta">
				<xsl:attribute name="name">dc.coverage</xsl:attribute>
				<xsl:attribute name="content"><xsl:value-of select="." /></xsl:attribute>
			</xsl:element>
		</xsl:for-each>
	</xsl:template>

<xsl:template name="toc">
	<xsl:variable name="file">
		<xsl:value-of select="ead/eadheader/eadid" />
	</xsl:variable>
	<h3>
		TABLE OF CONTENTS
	</h3>
	<br>
	</br>
	<xsl:if test="ead/archdesc/did">
		<p>
			<b>
				<a href="#a1">
					<xsl:value-of select="ead/archdesc/did/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/acqinfo[string-length(text()|*)!=0] | ead/archdesc/separatedmaterial[string-length(text()|*)!=0] | ead/archdesc/originalsloc[string-length(text()|*)!=0] | ead/archdesc/relatedmaterial[string-length(text()|*)!=0] | ead/archdesc/processinfo[string-length(text()|*)!=0] | ead/archdesc/altformavail[string-length(text()|*)!=0] | ead/archdesc/prefercite[string-length(text()|*)!=0] | ead/archdesc/accessrestrict[string-length(text()|*)!=0] | ead/archdesc/userestrict[string-length(text()|*)!=0] | ead/archdesc/custodialhist[string-length(text()|*)!=0] | ead/archdesc/appraisal[string-length(text()|*)!=0] | ead/archdesc/accruals[string-length(text()|*)!=0]">
	</xsl:if>
	<xsl:if test="ead/archdesc/acqinfo[string-length(text()|*)!=0] | ead/archdesc/separatedmaterial[string-length(text()|*)!=0] | ead/archdesc/originalsloc[string-length(text()|*)!=0] | ead/archdesc/relatedmaterial[string-length(text()|*)!=0] | ead/archdesc/processinfo[string-length(text()|*)!=0] | ead/archdesc/altformavail[string-length(text()|*)!=0] | ead/archdesc/prefercite[string-length(text()|*)!=0] | ead/archdesc/accessrestrict[string-length(text()|*)!=0] | ead/archdesc/userestrict[string-length(text()|*)!=0] | ead/archdesc/custodialhist[string-length(text()|*)!=0] | ead/archdesc/appraisal[string-length(text()|*)!=0] | ead/archdesc/accruals[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a14">
					<xsl:text>
						Administrative Information
					</xsl:text>
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/bioghist[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a2">
					<xsl:value-of select="ead/archdesc/bioghist/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/scopecontent[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a3">
					<xsl:value-of select="ead/archdesc/scopecontent/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/arrangement[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a4">
					<xsl:value-of select="ead/archdesc/arrangement/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/controlaccess[string-length(text()|*)!=0]">
		<p style="margin-top:-5pt">
			<b>
				<a href="#a12">
					<xsl:value-of select="ead/archdesc/controlaccess/head" />
				</a>
			</b>
		</p>
	</xsl:if>
	<xsl:if test="ead/archdesc/dsc[string-length(text()|*)!=0]">
		<a href="#a23">
			<p style="margin-top:-5pt">
				<b>
					<xsl:value-of select="ead/archdesc/dsc/head" />
				</b>
			</p>
		</a>
		<xsl:for-each select="ead/archdesc/dsc/c01">
			<p style="margin-left:10pt; margin-top:-5pt">
				<b>
					<font size="-1">
						<a>
							<xsl:attribute name="href">
								#series
								<xsl:number value="position()" format="1" />
							</xsl:attribute>
							<xsl:choose>
								<xsl:when test="did/unittitle/unitdate">
									<xsl:for-each select="did/unittitle">
										<xsl:apply-templates select="." />
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:apply-templates select="did/unittitle" />
									<xsl:text>
									</xsl:text>
									<xsl:apply-templates select="did/unitdate" />
								</xsl:otherwise>
							</xsl:choose>
						</a>
					</font>
				</b>
			</p>
		</xsl:for-each>
		<xsl:for-each select="//odd">
			<xsl:if test="//odd[string-length(text()|*)!=0]/head">
				<p style="margin-top:-5pt">
					<b>
						<a href="#{@id}"><xsl:value-of select="head" /></a>
					</b>
				</p>
			</xsl:if>
		</xsl:for-each>
		<xsl:if test="ead/archdesc/otherfindaid[string-length(text()|*)!=0]">
			<p style="margin-top:-5pt">
				<b>
					<a href="#a8">
						<xsl:value-of select="ead/archdesc/otherfindaid/head" />
					</a>
				</b>
			</p>
		</xsl:if>
		<xsl:if test="ead/archdesc/index[string-length(text()|*)!=0]">
			<p style="margin-top:-5pt">
				<b>
					<a href="#a9">
						<xsl:value-of select="ead/archdesc/index/head" />
					</a>
				</b>
			</p>
		</xsl:if>
		<xsl:if test="ead/archdesc/bibliography[string-length(text()|*)!=0]">
			<p style="margin-top:-5pt">
				<b>
					<a href="#a10">
						<xsl:value-of select="ead/archdesc/bibliography/head" />
					</a>
				</b>
			</p>
		</xsl:if>
	</xsl:if>
</xsl:template>

<xsl:template name="cover">
	<xsl:for-each select="ead/eadheader/filedesc/titlestmt">
		<p style="text-align:center">
			<a name="a0">
				<img src="../../images/website/36aaa.gif"></img>
			</a>
		</p>
		<xsl:if test="string-length(titleproper)">
			<h1 align="center">
				<xsl:value-of select="titleproper"/>
			</h1>				
		</xsl:if>
		<h2 align="center">
			<xsl:value-of select="subtitle"/>
		</h2>
		<!-- Loren added Author and Address info -->
		<h3 align="center">
			<xsl:value-of select="author"/>
		</h3>
		<xsl:if test="string-length(sponsor)">
			<h4 align="center">
				<xsl:value-of select="sponsor"/>
			</h4>
		</xsl:if>
	</xsl:for-each>
	
	<h5 align="center">
		<xsl:value-of select="ead/eadheader/filedesc/publicationstmt/date"/>
	</h5>
	
	<ul>
		<b>Contact Information</b>
		
		<dd>Reference Department</dd>
		<dd>Archives of American Art</dd>
		<dd>Smithsonian Institution</dd>
		<dd>Washington. D.C. 20560</dd>
		<dd>www.aaa.si.edu/askus</dd>
	</ul>
	
	<hr></hr>
</xsl:template>

<!--This template rule formats the top-level did element.-->
<xsl:template name="archdesc-did">
		
	<!--For each element of the did, this template inserts the value of the LABEL attribute or, if none is present, a default value.-->
	
	<xsl:for-each select="ead/archdesc/did">
		<table width="100%">
			<tr>
				<td width="5%"></td><td width="20%"></td><td width="75"></td>
			</tr>
			<tr>
				<td colspan="3">
					<h3>
						<a name="a1">
							<xsl:apply-templates select="head"/>
						</a>
					</h3>
				</td>
			</tr>
			<xsl:if test="origination[string-length(text()|*)!=0]">
				<xsl:for-each select="origination">
					<xsl:choose>
						<xsl:when test="@label">
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:value-of select="@label"/></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:when>
						<xsl:otherwise>
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:text>Creator: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
			
			<!-- Tests for and processes various permutations of unittitle and unitdate.-->
			<xsl:for-each select="unittitle">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates
									select="text() |* [not(self::unitdate)]"/>
							</td>
						</tr>
					</xsl:when>
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Title: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates
									select="text() |* [not(self::unitdate)]"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
				
				<xsl:if test="child::unitdate">
					<xsl:choose>
						<xsl:when test="./unitdate/@label">
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:value-of
											select="./unitdate/@label"/></b>
								</td>
								<td>
									<xsl:apply-templates
										select="./unitdate"/>
								</td>
							</tr>
						</xsl:when>
						<xsl:otherwise>
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:text>Dates: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates
										select="./unitdate"/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:if>
			</xsl:for-each>
			
			
			<!-- Processes the unit date if it is not a child of unit title but a child of did, the current context.-->
			<xsl:if test="unitdate">
				<xsl:for-each select="unitdate[string-length(text()|*)!=0]">
					<xsl:choose>
						<xsl:when test="./@label">
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:value-of select="./@label"/></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:when>
						<xsl:otherwise>
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:text>Dates: </xsl:text></b>
								</td>
								<td>
									<xsl:apply-templates select="."/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
			<xsl:if test="abstract[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="abstract"/>
							</td>
						</tr>
					</xsl:when>
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Abstract: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="abstract"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="physdesc[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="physdesc"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Extent: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="physdesc"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="langmaterial[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="langmaterial"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Language: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="langmaterial"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="unitid[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="unitid"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Identification: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="unitid"/>
								
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="physloc[string-length(text()|*)!=0]">
				<xsl:choose>
					<xsl:when test="@label">
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:value-of select="@label"/></b>
							</td>
							<td>
								<xsl:apply-templates select="physloc"/>
							</td>
						</tr>
					</xsl:when>
					
					<xsl:otherwise>
						<tr>
							<td></td>
							<td valign="top">
								<b><xsl:text>Location: </xsl:text></b>
							</td>
							<td>
								<xsl:apply-templates select="physloc"/>
							</td>
						</tr>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="note[string-length(text()|*)!=0]">
				<xsl:for-each select="note">
					<xsl:choose>
						<xsl:when test="@label">
							<tr>
								<td></td>
								<td valign="top">
									<b><xsl:value-of select="@label"/></b>
								</td>
							</tr>
							<xsl:for-each select="p">
								<tr>
									<td></td>
									<td valign="top">
										<xsl:apply-templates/>
									</td>
								</tr>
							</xsl:for-each>
						</xsl:when>
						
						<xsl:otherwise>
							<tr>
								<td></td>
								<td valign="top">
									<b>Location:</b>
								</td>
								<td>
									<xsl:apply-templates select="note"/>
								</td>
							</tr>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
			</xsl:if>
			
		</table>
		<hr></hr>
		
	</xsl:for-each>
</xsl:template>

<!--This template rule formats a top-level admininfo element.-->
<xsl:template name="archdesc-admininfo">
	<xsl:if
		test="ead/archdesc/acqinfo[string-length(text()|*)!=0] | ead/archdesc/separatedmaterial[string-length(text()|*)!=0] | ead/archdesc/originalsloc[string-length(text()|*)!=0] | ead/archdesc/relatedmaterial[string-length(text()|*)!=0] | ead/archdesc/altformavail[string-length(text()|*)!=0] | ead/archdesc/processinfo[string-length(text()|*)!=0] | ead/archdesc/prefercite[string-length(text()|*)!=0] | ead/archdesc/custodialhist[string-length(text()|*)!=0] | ead/archdesc/appraisal[string-length(text()|*)!=0] | ead/archdesc/accruals[string-length(text()|*)!=0]">
		<h3>
			<a name="a14">
				<b><xsl:text>Administrative Information</xsl:text></b>
			</a>
		</h3>
		<xsl:for-each select="ead/archdesc/acqinfo">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/separatedmaterial">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>			
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/originalsloc">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/relatedmaterial">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/altformavail">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/processinfo">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/prefercite">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/accessrestrict">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/userestrict">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<xsl:for-each select="ead/archdesc/accruals">
			<h4 style="margin-left : 15pt">
				<b><xsl:value-of select="head"/></b>
			</h4>
			<xsl:for-each select="p">
				<p style="margin-left : 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>						
		</xsl:for-each>
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>

<!-- Loren end insert -->

<!--This template rule formats the top-level bioghist element.-->
<!--This template rule formats the top-level bioghist element.-->
<xsl:template name="archdesc-bioghist">		
	<xsl:if test="ead/archdesc/bioghist[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/bioghist">
			<xsl:apply-templates/>
			<p>
				<a href="#a0">Return to the Table of Contents</a>
			</p>
			<hr></hr>
		</xsl:for-each>
	</xsl:if>
</xsl:template>

<xsl:template match="ead/archdesc/bioghist/head">
	<h3>
		<a name="a2">
			<xsl:apply-templates/>
		</a>
	</h3>
</xsl:template>

<xsl:template match="ead/archdesc/bioghist/p">
	<p style="margin-left: 30pt">
		<xsl:apply-templates/>
	</p>
</xsl:template>

<xsl:template match="ead/archdesc/bioghist/chronlist">
	<xsl:apply-templates/>
</xsl:template>
			
<!--This template rule formats the scopecontent element.-->
<xsl:template name="archdesc-scopecontent">
	<xsl:if test="ead/archdesc/scopecontent[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/scopecontent">
			<xsl:apply-templates/>
		</xsl:for-each>
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>

<xsl:template match="ead/archdesc/scopecontent/head">
	<h3><a name="a3"><xsl:apply-templates/></a></h3>
</xsl:template>

<xsl:template match="ead/archdesc/scopecontent/p">
	<p style="margin-left: 30pt">
		<xsl:apply-templates/>
	</p>
</xsl:template>

<!-- Index Terms -->
<xsl:template name="archdesc-control">
	<xsl:if test="ead/archdesc/controlaccess[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/controlaccess">
			<h3>
				<a name="a12">
					<xsl:apply-templates select="head"/>
				</a>
			</h3>
			<p style="padding-left: 30pt;">
				<xsl:apply-templates select="p"/>
			</p>
			
			<xsl:for-each select="./controlaccess">
				<xsl:if test="string-length(head)">
					<h4 style="padding-left: 30pt; padding-bottom: 0; margin-bottom:0;"><xsl:apply-templates select="head"/></h4>
				</xsl:if>
				
				<ul style="list-style:none;">
					<xsl:for-each select="subject |corpname | persname | famname| genreform | title | geogname | occupation">
						<xsl:sort select="."/>
						<li style="padding-left: 30pt;">
							<xsl:apply-templates select="."/>									
						</li>
					</xsl:for-each>							
				</ul>
			</xsl:for-each>
		</xsl:for-each>
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>
	
<!-- This formats an arrangement list embedded in a scope content statement.-->
<xsl:template match="ead/archdesc/scopecontent/arrangement">
	<xsl:for-each select="p">
		<p style="margin-left: 30pt">
			<xsl:apply-templates select="."/>
		</p>
	</xsl:for-each>
	<xsl:for-each select="list">
		<dl>
			<xsl:for-each select="item">
				<dd style="margin-left: 30pt">
					<a><xsl:attribute name="href">#series<xsl:number/></xsl:attribute><xsl:apply-templates select="."/></a>
				</dd>
			</xsl:for-each>				
		</dl>
	</xsl:for-each>
</xsl:template>


<!--This template rule formats the arrangement element.-->
<xsl:template name="archdesc-arrangement">
	<xsl:if test="ead/archdesc/arrangement[string-length(text()|*)!=0]">
		<xsl:for-each select="ead/archdesc/arrangement">
			<h3>
				<a name="a4">
					<xsl:apply-templates select="head"/>
				</a>
			</h3>
	
			<xsl:for-each select="p">
				<p style="margin-left: 30pt">
					<xsl:apply-templates select="."/>
				</p>
			</xsl:for-each>
				
			<xsl:for-each select="list">
				<p style="margin-left: 30pt">
					<xsl:apply-templates select="head"/>						
				</p>
				<ul style="list-style: none;">
					<xsl:for-each select="item">
						<li style="padding-left: 30pt;">
							<a><xsl:attribute name="href">#series<xsl:number/></xsl:attribute><xsl:apply-templates select="."/></a>							
						</li>
					</xsl:for-each>						
				</ul>
			</xsl:for-each>
		</xsl:for-each>
		<p>
			<a href="#a0">Return to the Table of Contents</a>
		</p>
		<hr></hr>
	</xsl:if>
</xsl:template>

	<!--This template rule formats the top-level otherfindaid element.-->
	<xsl:template name="archdesc-otherfindaid">
		<xsl:if test="ead/archdesc/otherfindaid[string-length(text()|*)!=0]">
			<xsl:for-each select="ead/archdesc/otherfindaid">
				<h3>
					<a name="a8">
						<b><xsl:apply-templates select="head"/></b>
					</a>
				</h3>
				<xsl:for-each select="p">
					<p style="margin-left : 30pt">
						<xsl:apply-templates select="."/>
					</p>
				</xsl:for-each>
			</xsl:for-each>
			<p>
				<a href="#a0">Return to the Table of Contents</a>
			</p>
			<hr></hr>
		</xsl:if>
	</xsl:template>

<xsl:template name="dsc">
	<xsl:for-each select="ead/archdesc/dsc">
		<h3><a name="a23"><xsl:apply-templates select="head"/></a></h3>
		
		<xsl:if test="string-length(p)!=0">
			<p style="margin-left: 25 pt">
				<i><xsl:apply-templates select="p"/></i>
			</p>
		</xsl:if>

		<xsl:apply-templates select="c01"/>
		
	</xsl:for-each>
</xsl:template>

<xsl:template name="unittitle-stuff">
<!--This named template defines the processing of unittitle and unitdates in a way that
is applicable at all component levels.   It is invoked throughout the following templates.
Unitdates may be the children either of unittitle or did.  This templates sorts those options
out.  It also includes conditional processing to handle situations where unitdate elements are
included in the markup but empty of PCDATA content.-->
<xsl:choose>
<!--When unitdate is a child of unittitle.-->
  <xsl:when test="unittitle/unitdate">
    <xsl:for-each select="unittitle">
      <!--Inserts the text of unittitle and any children other than unitdate.-->
      <xsl:apply-templates select="text()|*[not(self::unitdate)]"/>
        <!--Tests to see if the unitdate has content and adds it and separating space
        if it does.-->
        <xsl:if test="string-length(./unitdate)!=0">
					<xsl:text>
					</xsl:text>
          <xsl:apply-templates select="./unitdate"/>
        </xsl:if>
    </xsl:for-each>
  </xsl:when>
<!--When unitdate is a child of did.-->
<xsl:otherwise>
  <xsl:apply-templates select="unittitle"/>
  <xsl:if test="string-length(unitdate)!=0">
				<xsl:text>
				</xsl:text>
    <xsl:apply-templates select="unitdate"/>
  </xsl:if>
</xsl:otherwise>
</xsl:choose>
</xsl:template>

<!-- Every component level will be treated the same.  This allows for minimizing code-repetition, not creating out of memory problems, and faster execution -->
<xsl:template match="c01|c02|c03|c04|c05|c06">
	<!-- The indent level is passed in from the previous component in the hierarchy. That way, we get the correct visual nesting of folder headings based on the nesting of components -->
	<xsl:param name="indentLevel" select="0" />
	
	<!-- Check to see if this component is a series -->
	<xsl:variable name="isSeries">
		<xsl:call-template name="checkForSeries">
			<xsl:with-param name="currentComponent" select="." />
		</xsl:call-template>
	</xsl:variable>
	
	<!-- The component will be displayed either as a series or a container -->
	<xsl:choose>
		<!-- If this component is a series, display it as a series -->
		<xsl:when test="$isSeries='true'">
			<xsl:call-template name="display-series">
				<xsl:with-param name="currentComponent" select="." />
			</xsl:call-template>	
		</xsl:when>
		<!-- Otherwise, simply display the component as a container.  All non-series components (folder groupings, folders, items) get displayed the same way -->
		<xsl:otherwise>
		
			<!-- 
				Determine the previous box, reel, folder, and frame numbers.
				We're using a (nearly) identical template call for each container 
				type to return the previous container number for that type
			-->
			
			<!-- If the current component has a box number, get the previous box number -->
			<xsl:variable name="previousBoxNumber">
				<xsl:choose>
					<xsl:when test="string-length(did/container[@type='box'])">
							<xsl:call-template name="determineContainerNumber">
								<xsl:with-param name="currentComponent" select="."></xsl:with-param>
								<xsl:with-param name="componentPosition" select="position()" />
								<xsl:with-param name="containerType"><xsl:text>box</xsl:text></xsl:with-param>
							</xsl:call-template>
					</xsl:when>
					<xsl:otherwise><xsl:text /></xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<!-- If the current component has a reel number, get the previous reel number -->
			<xsl:variable name="previousReelNumber">
				<xsl:choose>
					<xsl:when test="string-length(did/container[@type='reel'])">
							<xsl:call-template name="determineContainerNumber">
								<xsl:with-param name="currentComponent" select="."></xsl:with-param>
								<xsl:with-param name="componentPosition" select="position()" />
								<xsl:with-param name="containerType"><xsl:text>reel</xsl:text></xsl:with-param>
							</xsl:call-template>
					</xsl:when>
					<xsl:otherwise><xsl:text /></xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<!-- If the current component has a folder number, get the previous folder number -->
			<xsl:variable name="previousFolderNumber">
				<xsl:choose>
					<xsl:when test="string-length(did/container[@type='folder'])">
							<xsl:call-template name="determineContainerNumber">
								<xsl:with-param name="currentComponent" select="."></xsl:with-param>
								<xsl:with-param name="componentPosition" select="position()" />
								<xsl:with-param name="containerType"><xsl:text>folder</xsl:text></xsl:with-param>
							</xsl:call-template>
					</xsl:when>
					<xsl:otherwise><xsl:text /></xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<!-- If the current component has a frame number, get the previous frame number -->
			<xsl:variable name="previousFrameNumber">
				<xsl:choose>
					<xsl:when test="string-length(did/container[@type='frame'])">
							<xsl:call-template name="determineContainerNumber">
								<xsl:with-param name="currentComponent" select="."></xsl:with-param>
								<xsl:with-param name="componentPosition" select="position()" />
								<xsl:with-param name="containerType"><xsl:text>frame</xsl:text></xsl:with-param>
							</xsl:call-template>
					</xsl:when>
					<xsl:otherwise><xsl:text /></xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
						
			<xsl:call-template name="display-container">
				<xsl:with-param name="currentComponent" select="." />
				<xsl:with-param name="indentLevel" select="$indentLevel" />
				<xsl:with-param name="previousBoxNumber" select="normalize-space($previousBoxNumber)" />
				<xsl:with-param name="previousReelNumber" select="normalize-space($previousReelNumber)" />
				<xsl:with-param name="previousFolderNumber" select="normalize-space($previousFolderNumber)" />
				<xsl:with-param name="previousFrameNumber" select="normalize-space($previousFrameNumber)" />
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>

	<!-- This determines the indent level to pass on to children of this component -->
	<xsl:variable name="nextIndentLevel">
		<xsl:choose>
			<xsl:when test="$isSeries != 'true'">
				<xsl:value-of select="number($indentLevel + 1)" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="0" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	
	<xsl:apply-templates select="c02|c03|c04|c05|c06">
		<xsl:with-param name="indentLevel" select="$nextIndentLevel" />
	</xsl:apply-templates>
</xsl:template>

<!-- 
	Any component with a level or otherlevel attribute becomes a series.
	
	This has a standard display
-->
<xsl:template name="display-series">
	<xsl:param name="currentComponent" />
	
	<h3>
		<!-- We need to determine the "anchor" string for the named anchor that users will follow to this series or subseries -->
		<xsl:variable name="seriesAnchorPrefix">
			<xsl:call-template name="generateAnchorString" />
		</xsl:variable>
		
		<!-- Here is where we put the named anchor link -->
		<a><xsl:attribute name="name"><xsl:value-of select="$seriesAnchorPrefix" /></xsl:attribute><xsl:text>  </xsl:text></a>

		<xsl:apply-templates select="$currentComponent/did/head"/>					
		<xsl:apply-templates select="$currentComponent/did/unitid"/>

		<xsl:for-each select="$currentComponent/did">
			<xsl:call-template name="unittitle-stuff"/>
		</xsl:for-each>
		<!-- Adding text here, otherwise, there isn't any space between the title and the physical description -->
		<xsl:text> </xsl:text>
		<xsl:apply-templates select="$currentComponent/did/physdesc"/>
	</h3>
	
	<xsl:for-each select="$currentComponent/scopecontent/note/p|scopecontent/p">
		<p>
			<xsl:apply-templates select="."/>
		</p>
	</xsl:for-each>

	<xsl:apply-templates select="$currentComponent/arrangement" />			
</xsl:template>

<!-- 
	Each container heading is displayed as its own table. The current component representing the container heading is
	passed in as the currentComponent variable.
	
	The code that "displays" the component is responsible for determining the previous container numbers (described further below
	 in details)
	 
	 We also pass through information about the indent level to support indenting of titles and the scope content.
-->
<xsl:template name="display-container">
	<xsl:param name="currentComponent" />
	<xsl:param name="indentLevel" />
	<xsl:param name="previousBoxNumber" />
	<xsl:param name="previousReelNumber" />
	<xsl:param name="previousFolderNumber" />
	<xsl:param name="previousFrameNumber" />
			
	<!-- Added variables to allow for mixed container types -->
	<xsl:variable name="boxnumber" select="$currentComponent/did/container[@type='box']"/>
	<xsl:variable name="foldernumber" select="$currentComponent/did/container[@type='folder']"/>
	
	<xsl:variable name="reelnumber" select="$currentComponent/did/container[@type='reel']"/>
	<xsl:variable name="framenumber" select="$currentComponent/did/container[@type='frame']"/>
			
	<table width="600">
			
		<!-- Column headings -->

		<!-- We need to set the width for second column to be enough to hold most of the display possibilities that exist -->
		<xsl:variable name="columnWidthStyle">
			<xsl:choose>
				<xsl:when test="string-length($boxnumber) and string-length($reelnumber) and string-length($framenumber)">
					<xsl:text>width:150px</xsl:text>
				</xsl:when>
				<xsl:when test="string-length($reelnumber) and string-length($framenumber)">
					<xsl:text>width:100px</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>width:75px</xsl:text>								
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<!--
			This checks to see if the box number is different from the previous box number OR, if there's
			no box number, whether the reel numbers are different.  If either of these is true, we should
			show the column headings
		-->
		<xsl:choose>
			<xsl:when test="
									(string-length($boxnumber) and $boxnumber != $previousBoxNumber) or 
									(not(string-length($boxnumber)) and string-length($reelnumber) and not($reelnumber = $previousReelNumber)) 
							">
				<tr>
					<td style="width:75px">
						<br/>
						<xsl:choose>
							<xsl:when test="string-length($boxnumber)">
								<b>Box</b>							
							</xsl:when>
							<xsl:when test="string-length($reelnumber)">
								<b>Reel</b>
							</xsl:when>
						</xsl:choose>												
					</td>
					
					<td><xsl:attribute name="style"><xsl:value-of select="$columnWidthStyle" /></xsl:attribute>
						<br/>
						<xsl:choose>
							<!-- If we have a box number and a reel number, then this is a box/reel finding aid -->
							<xsl:when test="string-length($boxnumber) and string-length($reelnumber)">
								<b>Reel</b>
								<!-- If we also have frame information, it's a box/reel/frame finding aid -->
								<xsl:if test="string-length($framenumber)">
									<b>(Frames)</b>
								</xsl:if>
							</xsl:when>										
							<!-- If we have folder information, then this is a box/folder finding aid  -->
							<xsl:when test="string-length($foldernumber)">
								<b>Folder</b>
							</xsl:when>
							<!-- If we also have frame information, but no box number, this is a reel/frame finding aid -->							
							<xsl:when test="string-length($framenumber)">
								<b>Frame</b>
							</xsl:when>		
							<!-- This case occurs when there isn't a secondary container type -->								
							<xsl:otherwise>
								<br />
							</xsl:otherwise>
						</xsl:choose>
					</td>
					<td><br /></td>											
				</tr>
			</xsl:when>
		</xsl:choose>
		<tr style="vertical-align: top" valign="top">
			<!-- Container Values -->
			<td style="width:75px">
				<xsl:choose>
					<!-- In this case, we first test for the NEGATIVE of the criteria we used to determine whether to display the column headings -->
					<xsl:when test="	not(
											(
											(string-length($boxnumber) and not($boxnumber = $previousBoxNumber)) or 
											(not(string-length($boxnumber)) and string-length($reelnumber) and not($reelnumber = $previousReelNumber)))
										)
							">
						<br />				
					</xsl:when>
					<!-- Display the main container value -->
					<xsl:when test="string-length($boxnumber)">
						<xsl:value-of select="$boxnumber" />												
					</xsl:when>
					<xsl:when test="string-length($reelnumber)">
						<xsl:value-of select="$reelnumber" />
					</xsl:when>
				</xsl:choose>												
			</td>
			<!-- The width for this column should be enough to hold most of the display possibilities that exist -->
			<td><xsl:attribute name="style"><xsl:value-of select="$columnWidthStyle" /></xsl:attribute>
				<xsl:choose>
					<!-- We have to check BOTH to see if the box/reel number changed AND if the secondary container value has changed. We display no value if they're BOTH the same   -->
					<xsl:when test="	not(
											(
											(string-length($boxnumber) and not($boxnumber = $previousBoxNumber)) or 
											(not(string-length($boxnumber)) and string-length($reelnumber) and not($reelnumber = $previousReelNumber)))
										)
										and 
										not(
											(string-length($boxnumber) and string-length($reelnumber) and not($reelnumber = $previousReelNumber)) or 													
											(string-length($foldernumber) and not($foldernumber = $previousFolderNumber)) or
											(string-length($framenumber) and not($framenumber = $previousFrameNumber))
										)
							">
						<br />				
					</xsl:when>
					<!-- Display the secondary container information -->
					<xsl:when test="string-length($boxnumber) and string-length($reelnumber)">
						<xsl:value-of select="$reelnumber" />
						<!-- If we also have frame information, add that to the display -->
						<xsl:if test="string-length($framenumber)">
							(<xsl:value-of select="$framenumber" />)
						</xsl:if>						
					</xsl:when>										
					<xsl:when test="string-length($foldernumber)">
						<xsl:value-of select="$foldernumber" />
					</xsl:when>
					<xsl:when test="string-length($framenumber)">
						<xsl:value-of select="$framenumber" />
					</xsl:when>
					<xsl:otherwise>
						<br />
					</xsl:otherwise>										
				</xsl:choose>
			</td>											

			<td>
				<!-- Displays the container title, with date, and physical description with proper indentation -->
				<div><xsl:attribute name="style"><xsl:text>padding-left:</xsl:text><xsl:value-of select="number($indentLevel*25)" /><xsl:text>pt</xsl:text></xsl:attribute>
					<!-- The 7 lines below used to be enclosed in a variable statement above for $headingtext, but this caused a problem with italics being dropped, so this code has been moved down to here -->
					<xsl:apply-templates select="$currentComponent/did/unitid"/>
					<xsl:for-each select="$currentComponent/did">
						<xsl:call-template name="unittitle-stuff"/>
					</xsl:for-each>
					<xsl:text> </xsl:text>
					<xsl:apply-templates select="$currentComponent/did/physdesc"/>
					<xsl:apply-templates select="$currentComponent/did/abstract"/>										
				</div>
				<!-- Displays the cscope content with proper indentation -->
				<xsl:if test="string-length(scopecontent)">
					<div><xsl:attribute name="class"><xsl:text>indent</xsl:text><xsl:value-of select="$indentLevel" /></xsl:attribute>
						<xsl:for-each select="$currentComponent/scopecontent/p">
							<xsl:apply-templates/><br />
						</xsl:for-each>
					</div>								
				</xsl:if>
			</td>							
		</tr>					
	</table>
</xsl:template>

<xsl:template name="generateAnchorString">	
	<!-- Determine the anchor prefix -->
	<!--Creates a link that points to the series -->
	<xsl:variable name="level1Count">
		<xsl:number count="c01" from="dsc"/>
	</xsl:variable>
	<xsl:variable name="seriesAnchorPrefix">
		<xsl:value-of select="concat('series',string($level1Count))" />
		<xsl:variable name="level2Count">
			<xsl:number count="c02" from="c01"/>
		</xsl:variable>
		<xsl:if test="number($level2Count)">
			<xsl:value-of select="concat('_',string($level2Count))" />			
		</xsl:if>
		<xsl:variable name="level3Count">
			<xsl:number count="c03" from="c02"/>
		</xsl:variable>
		<xsl:if test="number($level3Count)">
			<xsl:value-of select="concat('_',string($level3Count))" />			
		</xsl:if>
		<xsl:variable name="level4Count">
			<xsl:number count="c04" from="c03"/>
		</xsl:variable>
		<xsl:if test="number($level4Count)">
			<xsl:value-of select="concat('_',string($level4Count))" />			
		</xsl:if>
		<xsl:variable name="level5Count">
			<xsl:number count="c05" from="c04"/>
		</xsl:variable>
		<xsl:if test="number($level5Count)">
			<xsl:value-of select="concat('_',string($level5Count))" />			
		</xsl:if>
		<xsl:variable name="level6Count">
			<xsl:number count="c06" from="c05"/>
		</xsl:variable>
		<xsl:if test="number($level6Count)">
			<xsl:value-of select="concat('_',string($level6Count))" />			
		</xsl:if>
	</xsl:variable>
	
	<xsl:value-of select="$seriesAnchorPrefix" />
</xsl:template>


<!-- A "function" for determining whether the current component is a series or not -->
<xsl:template name="checkForSeries">
	<xsl:param name="currentComponent" />
	<xsl:choose>
		<xsl:when test="$currentComponent/@level!='' or $currentComponent/@otherlevel!=''"> 
			<xsl:text>true</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>false</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>

<!-- A "function" for determining whether the current component is a series or not -->
<xsl:template name="checkForFolderGroup">
	<xsl:param name="currentComponent" />
	<xsl:choose>
		<xsl:when test="$currentComponent/@level!='' or $currentComponent/@otherlevel!=''"> 
			<xsl:text>true</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>false</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<!-- 
	This template attempts to determine the previous container number for the current container type.  This turns out to be very complicated:
	the previous container number, could come from the parent of the current component, from the component's previous sibling, or from a child 
	of that previous sibling, with permutations on this.
	
	The various choices are all outlined below. There are many of them. Each is documented as to why it comes in the order specified 
	
-->
<xsl:template name="determineContainerNumber">
	<xsl:param name="currentComponent" />
	<xsl:param name="componentPosition" />
	<xsl:param name="containerType" />
	
	<xsl:message><xsl:value-of select="$containerType" /></xsl:message>
	<xsl:for-each select="$currentComponent">
		<xsl:choose>
			<!-- If this is the first child of series level component, the previous container number is blank -->
			<xsl:when test="$componentPosition = 1 and (string-length(./parent::node()[@level]) or string-length(./parent::node()[@otherlevel]))">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>This is the first child of a series component</xsl:text></xsl:message>
				<xsl:text></xsl:text>
			</xsl:when>

			<!-- If this is the first element for its parent component, Get the container number from the parent for this component -->
			<xsl:when test="$componentPosition = 1 and ./parent::node()/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from parent</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c06. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the previous sibling of this c06 -->
			<xsl:when test="./parent::node()/c06[number($componentPosition -1)]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous c06 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c06[number($componentPosition -1)]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of the parent of the c05 parent of this c06 -->
			<xsl:when test="./parent::node()/preceding-sibling::c05/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous parent c05</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/preceding-sibling::c05/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c05. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the last c06 child of the previous c05 sibling of this c05 -->
			<xsl:when test="./parent::node()/c05[number($componentPosition -1)]/c06[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c06 precedent of previous c04</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c05[number($componentPosition -1)]/c06[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of this c05 -->
			<xsl:when test="./parent::node()/c05[number($componentPosition -1)]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous c05 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c05[number($componentPosition -1)]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of the parent of the c04 parent of this c05 -->
			<xsl:when test="./parent::node()/preceding-sibling::c04/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous parent c04</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/preceding-sibling::c04/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c04. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the last c06 child of the last c05 child of the previous c04 sibling of this c04 -->
			<xsl:when test="./parent::node()/c04[number($componentPosition -1)]/c05[last()]/c06[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c06 precedent of previous c03</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c04[number($componentPosition -1)]/c05[last()]/c06[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c05 child of the previous c04 sibling of this c04 -->
			<xsl:when test="./parent::node()/c04[number($componentPosition -1)]/c05[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c05 precedent of previous c03</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c04[number($componentPosition -1)]/c05[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of this c04 -->
			<xsl:when test="./parent::node()/c04[number($componentPosition -1)]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous c04 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c04[number($componentPosition -1)]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of the parent of the c03 parent of this c04 -->
			<xsl:when test="./parent::node()/preceding-sibling::c03/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous parent c03</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/preceding-sibling::c03/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c03. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the last c06 child of the last c05 child of the last c04 child of the previous c03 sibling of this c03 -->
			<xsl:when test="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/c05[last()]/c06[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c06 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/c05[last()]/c06[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c05 child of the last c04 child of the previous c03 sibling of this c03 -->
			<xsl:when test="parent::node()/c03[number($componentPosition -1)]/c04[last()]/c05[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c05 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/c05[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c04 child of the previous c03 sibling of this c03 -->
			<xsl:when test="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c04 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c03[number($componentPosition -1)]/c04[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of this c03 -->
			<xsl:when test="./parent::node()/c03[number($componentPosition -1)]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous c03 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c03[number($componentPosition -1)]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of the parent of the c02 parent of this c03 -->
			<xsl:when test="./parent::node()/preceding-sibling::c02/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous parent c02</xsl:text></xsl:message>
				<xsl:value-of select="parent::node()/preceding-sibling::c02/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- 
				All of the possible previous component possibilities for c02. The order is designed to ensure that the most nested cases are handled first,
				because otherwise they would be overridden by less nested options 
			-->

			<!-- Get the container number from the last c06 child of the last c05 child of the last c04 child of the last c03 child of the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/c05[last()]/c06[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c06 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/c05[last()]/c06[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c05 child of the last c04 child of the last c03 child of the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/c05[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c05 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/c05[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c04 child of the last c03 child of the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c04 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/c04[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the last c03 child of the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from last c03 precedent of previous c02</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/c03[last()]/did/container[@type=$containerType]" />
			</xsl:when>

			<!-- Get the container number from the previous sibling of this c02 -->
			<xsl:when test="./parent::node()/c02[number($componentPosition -1)]/did/container[@type=$containerType]">
				<xsl:message><xsl:value-of select="did/unittitle" /><xsl:text>Getting $containerType number from previous c02 sibling</xsl:text></xsl:message>
				<xsl:value-of select="./parent::node()/c02[number($componentPosition -1)]/did/container[@type=$containerType]" />
			</xsl:when>
			
			<xsl:otherwise>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:for-each>
</xsl:template>

<!-- Displays the biographical statement (not used by our finding aids) or arrangement note -->
<xsl:template match="   
						c01/bioghist | 
						c01/arrangement |
						c02/bioghist | 
						c02/arrangement |
						c03/bioghist | 
						c03/arrangement |
						c04/bioghist | 
						c04/arrangement |
						c05/bioghist | 
						c05/arrangement |
						c06/bioghist | 
						c06/arrangement 
	">		
	<xsl:for-each select="p">
		<p><xsl:apply-templates select="."/></p>
	</xsl:for-each>
</xsl:template>

<!-- Displays lists inside the arrangement note. We need custom lists to account for anchor links to subseries -->
<xsl:template match="
					c01/arrangement/p/list |
					c02/arrangement/p/list |
					c03/arrangement/p/list |
					c04/arrangement/p/list |
					c05/arrangement/p/list |
					c06/arrangement/p/list
	">
	<xsl:param name="currentComponent" />		
	
	<xsl:variable name="seriesAnchorPrefix">
		<xsl:call-template name="generateAnchorString" />
	</xsl:variable>
	
	<ul style="list-style:none">
		<xsl:for-each select="item">

			<!-- Append the number for the current item -->
			<xsl:variable name="seriesAnchor">
				<xsl:variable name="itemCount">
					<xsl:number count="item" from="list"/>
				</xsl:variable>
				<xsl:value-of select="concat('#',$seriesAnchorPrefix,'_',string($itemCount))" />								
			</xsl:variable>

			<li style="padding-left: 30pt;">
				<a><xsl:attribute name="href"><xsl:value-of select="$seriesAnchor" /></xsl:attribute>
					<xsl:apply-templates select="."/></a>							
			</li>
		</xsl:for-each>
	</ul>
</xsl:template>

	<!--This template rule formats the top-level bibliography element.-->
	<xsl:template name="archdesc-bibliography">
		<xsl:if test="ead/archdesc/bibliography[string-length(text()|*)!=0]">
			<xsl:for-each select="ead/archdesc/bibliography">
				<h3>
					<a name="a10">
						<b><xsl:apply-templates select="head"/></b>
					</a>
				</h3>
				<xsl:for-each select="p">
					<xsl:for-each select="bibref">
						<p style="margin-left : 30pt">
							<xsl:apply-templates select="."/>
						</p>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
			<p>
				<a href="#a0">Return to the Table of Contents</a>
			</p>
			<hr></hr>
		</xsl:if>
	</xsl:template>
	
	<!--This template rule formats the top-level odd element.-->
	<xsl:template name="archdesc-odd">
		<xsl:if test="//odd[string-length(text()|*)!=0]">
			<xsl:for-each select="//odd">
				<a name="{@id}"><xsl:text> </xsl:text></a>
				<xsl:if test="string-length(head)">
					<h3>
						<b><xsl:apply-templates select="head"/></b>
					</h3>
				</xsl:if>
				<xsl:for-each select="p">
					<xsl:if test="string-length(.)">
						<p style="margin-left : 30pt">
							<xsl:apply-templates select="."/>
						</p>
					</xsl:if>
				</xsl:for-each>
			</xsl:for-each>
			<p>
				<a href="#a0">Return to the Table of Contents</a>
			</p>
			<hr></hr>
		</xsl:if>
	</xsl:template>

	<xsl:template match="//odd/chronlist">
		<xsl:apply-templates/>
	</xsl:template>
	
	<!-- Loren added blockquote template -->
	<xsl:template match="blockquote">
		<blockquote>
			<p style="margin-left: 30pt">
				<xsl:apply-templates/>
			</p>
		</blockquote>
	</xsl:template>
	
	
	<!-- The following templates format the display of various RENDER attributes.-->
	
	<xsl:template match="*/title">
		<xsl:apply-templates/>
	</xsl:template>
	
	<xsl:template match="*/emph">
		<xsl:apply-templates/>
	</xsl:template>
	
	<xsl:template match="*[@render='bold']">
		<b>
			<xsl:apply-templates />
		</b>
	</xsl:template>
	
	<xsl:template match="*[@render='italic']">
		<i>
			<xsl:apply-templates />
		</i>
	</xsl:template>
	
	<xsl:template match="*[@render='underline']">
		<u>
			<xsl:apply-templates />
		</u>
	</xsl:template>
	
	<xsl:template match="*[@render='sub']">
		<sub>
			<xsl:apply-templates />
		</sub>
	</xsl:template>
	
	<xsl:template match="*[@render='super']">
		<super>
			<xsl:apply-templates />
		</super>
	</xsl:template>
	
	<xsl:template match="*[@render='quoted']">
		<xsl:text>"</xsl:text>
		<xsl:apply-templates />
		<xsl:text>"</xsl:text>
	</xsl:template>
	
	<xsl:template match="*[@render='boldquoted']">
		<b>
			<xsl:text>"</xsl:text>
			<xsl:apply-templates />
			<xsl:text>"</xsl:text>
		</b>
	</xsl:template>
	
	<xsl:template match="*[@render='boldunderline']">
		<b>
			<u>
				<xsl:apply-templates />
			</u>
		</b>
	</xsl:template>
	
	<xsl:template match="*[@render='bolditalic']">
		<b>
			<i>
				<xsl:apply-templates />
			</i>
		</b>
	</xsl:template>
	
	<xsl:template match="*[@render='boldsmcaps']">
		<font style="font-variant: small-caps">
			<b>
				<xsl:apply-templates />
			</b>
		</font>
	</xsl:template>
	
	<xsl:template match="*[@render='smcaps']">
		<font style="font-variant: small-caps">
			<xsl:apply-templates />
		</font>
	</xsl:template>
	
	<!-- This template converts a Ref element into an internal anchor.-->
	
	<xsl:template match="//ref">
		<xsl:variable name="target">
			<xsl:value-of select="@target"/>
		</xsl:variable>
		<a href="#{$target}">
			<xsl:apply-templates />
		</a>
	</xsl:template>
	
	<!-- This template converts a ExtRef element into an external anchor.-->
	
	<xsl:template match="//extref">
		<xsl:variable name="href">
			<xsl:value-of select="@href"/>
		</xsl:variable>
		<a href="{$href}">
			<xsl:apply-templates />
		</a>
	</xsl:template>
	
	<!-- Converts an ID attribute into the name attribute of an HTML anchor to form the target of a Ref element.-->
	
	<xsl:template match="*[@id]">
		<a name="{@id}">
			<xsl:apply-templates />
		</a>
	</xsl:template>
	
	
	<!--Formats a simple table. The width of each column is defined by the colwidth attribute in a colspec element.-->
	<xsl:template match="*/table">
		<xsl:for-each select="tgroup">
			<table width="100%">
				<tr>
					<xsl:for-each select="colspec">
						<td width="{@colwidth}"></td>
					</xsl:for-each>
				</tr>
				<xsl:for-each select="thead">
					<xsl:for-each select="row">
						<tr>
							<xsl:for-each select="entry">
								<td valign="top">
									<b>
										<xsl:apply-templates />
									</b>
								</td>
							</xsl:for-each>
						</tr>
					</xsl:for-each>
				</xsl:for-each>
				
				<xsl:for-each select="tbody">
					<xsl:for-each select="row">
						<tr>
							<xsl:for-each select="entry">
								<td valign="top">
									<xsl:apply-templates />
								</td>
							</xsl:for-each>
						</tr>
					</xsl:for-each>
				</xsl:for-each>
			</table>
		</xsl:for-each>
	</xsl:template>
	
	<!--This template rule formats a chronlist element.-->
	
	<xsl:template match="//chronlist">
		<table width="100%">
			<tr>
				<td width="5%">
				</td>
				<td width="30%">
				</td>
				<td width="65%">
				</td>
			</tr>
			
			<xsl:for-each select="listhead">
				<tr>
					<td></td>
					<td>
						<b>
							<xsl:apply-templates select="head01"/>
						</b>
					</td>
					<td>
						<b>
							<xsl:if test="head02[string-length(text()|*)!=0]">
								<xsl:apply-templates select="head02"/>
							</xsl:if>
						</b>
					</td>
				</tr>
			</xsl:for-each>
			
			<xsl:for-each select="chronitem">
				<tr>
					<td></td>
					<td valign="top">
						<xsl:apply-templates select="date"/>
					</td>
					<td valign="top">
						<xsl:apply-templates select="event"/>
					</td>
				</tr>
			</xsl:for-each>
		</table>
	</xsl:template>
	
	<!--This template rule formats a list element.-->
	<xsl:template match="//scopecontent/p/list|//odd/p/list">
		<xsl:if test="string-length(head)">
			<h4><xsl:apply-templates select="head"/></h4>
		</xsl:if>
		<dl>
		<xsl:for-each select="item">
			<dd style="margin-left: 30pt;">
				<xsl:apply-templates select="."/>
			</dd>
		</xsl:for-each>				
		</dl>
	</xsl:template>
</xsl:stylesheet>